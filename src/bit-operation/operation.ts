/**
 * https://blog.csdn.net/weixin_42216574/article/details/82885102
 * 原码
 * 利用二进制的第一位表示符号位，0标识正数，1表示负数
 * 一个数用二进制表示的话，取值范围 -111 1111 ~ +111 1111   -127 ~ 127
 * 反码
 * 一个数用原码表示容易理解的。但需要单独一个bit表示符号位，进行加法时，需要先识别某个二进制是正数还是负数，然后在进行相应的运算。
 * 这样效率不高，让计算机在进行运算时，不需要管符号位。也就是说让符号位也参与运算。
 * 补码
 * 补码的出现为了解决反码
 */

/**
 * 整数精度最多15位，小数精度最大位数17位
 *  Javascript内部，数值都是以64位浮点数的形式存储，但是做位运算时候，是以32位带符号的整数进行运算的，返回值也是一个32位带符号的整数
 */

/**
 * 位运算
 */
/**
 * & 与运算符
 * 两个位都是1时，结果才为1，否则为0
    1 0 0 1 1
&  1 1 0 0 1
    1 0 0 0 1
 */

/**
  * | 或运算符
  * 两个位都是0时，结果才为0，不同则为1
    1 0 0 1 1
|   1 1 0 0 1
    1 1 0 1 1

  */

/**
 * ^ 异或运算符
 * 两个位相同则为0，不同则为1
 */
/**
    1 0 0 1 1
^  1 1 0 0 1
---------------
    0 1 0 1 0
   */

/**
   * 
   * 0000 0101
   * 1111    1101
   * 1111 1101
   * ~按位非
   * ~按位取反运算。 0则变为1 , 1则变为0
   ~ 1 0 0 1 1
      0 1 1 0 0
   */
/**
   * 
   * 如果反码 第一位是1表示负数，则需要在反码基础上+1，否则-1 。负数在计算机里以补码存在
   1的二进制表示为 0000 0001
   反码由于第一位(符号位)是1，所以这个数是一个负数。js内部采用补码形式表示负数

   1
   原码 0000 0001
   反码 0111  1110
   补码 0111  1101      -1
   取反
            1000 0010

    2
        0000 0010
        0111  1101
        0111  1100
        1000 0011

    -2
    原码 1000 0010
    反码 1111  1101     +1
    补码 1111  1110
    取反
            000 0001
    -3 
    原码 1000 0011
            1111  1100
            1111  1101
            000  0010

    正数的补码和原码相同。
   */
/**
 * 原码、反码、补码
 */
/**
 十进制        原码                 反码            补码
 2          0000 0010        0000 0010    0000 0010
 -2         1000 0010        1111 1101        1111 1110
 */

/**
 * ~-1
 * 1000 0001
 * 0111 1110
 * 0000 0001
 */

/**
 * 负数位移运算
 * 有符号右移、左移
 * -2 << 1   -2 >> 1
 * -2原码 1000 0010
 * -2反码 1111 1101
 * -2补码 1111 1110 该补码对应的反码 -1
 *            1111 1101
 * 其中 -2 << 1
 *  11111111 11111111 11111111 11111100
 * -1
 *  11111111 11111111 11111111 11111011
 * 该反码对应的原码为：符号位不变，其他位取反
 * 10000000 00000000 00000000 00000100
 * */

/**
   * 无符号右移运算 (符号位会跟着一起移动)
   * 将第一个操作数向右移动指定的位数。向右被移出位被丢弃，左侧用0填充。
   * -2 >>> 1
   * -2 原码 
   * -2用原码表示为10000000 00000000 00000000 00000010
      -2用反码表示为11111111 11111111 11111111 11111101  
                                                                                     + 1
      -2用补码表示为11111111 11111111 11111111 11111110
      -2的补码右移1位为：01111111 11111111 11111111 11111111
      右移后对应的反码、原码为   01111111 11111111 11111111 11111111(因为符号位为0表示正数，正数的原码，反码，补码相同)
   */

/**
 *   << 左移运算符，向左进行移位操作，高位丢弃，低位补0
 *   1<<1
 *   0000 0001
 *   0000 0010   --- 2
 */

/**
 * >> 有符号右移
 * 指定操作数的二进制位数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧
 * 1 >> 1
 * 0000 0001
 * 0000 0000
 */

/**
 * 如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的
 * 1 - 1 = 1 + (-1) = [0000 0001] + [1000 0010] = -2
 * 为了解决原码做减法的问题，出现了反码
 * 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 =  [0000 0001]反 + [1111 1110]反 = [1000 0000]原  = - 0
 *  发现用反码计算减法，结果的真值部分是正确的，唯一的问题出现在 0 这个特殊数值。虽然理解 +0和-0是一样的。
 * 但是0带符号是没有任何意义的。而且会有[0000 0000]原和[1000 0000]原两个编码表示0
 * 于是出现了补码，解决了0的符号以及两个编码的问题
 * 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补 = [0000 0000]原
 */

 /**
  * 补码转换成原码
  * 两种情况
  * 1.最高为1，即为负数，最高位不变，其他按位取反
  * 2.最高为0，不用转化
  * 所有参与运算的都是以补码形式进行的结果也是补码。因此需要将补码转换成为原码的形式存在
  */