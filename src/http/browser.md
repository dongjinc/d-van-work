浏览器是个多进程结构

- 1.浏览器进程：标签页外的用户界面以及负责与浏览器其他进程协调工作
- 2.缓存进程
- 3.网络进程
- 4.GPU 进程 页面渲染
- 5.插件进程 flash

IE - Trident

Firefox Gecko

Safari Webkit

chrome/opera/edge Blink

进程：操作系统进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体
线程：操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务
当我们启动某个程序时，就会创建一个进程来执行任务代码，同时会为该进程分配内存空间，该应用程序的状态都保存在该内存空间里，当应用关闭时，该内存空间就会被 ‍ 回收

进程可以启动更多的进程来执行任务，由于每个进程分配的空间都是独立的，如果两个进程间需要传递某些数据则需要通过进程间通信管道 IPC 来传递，很多应用程序都是多进程结构，这样是为了避免某个进程卡死

特点： 1.进程间相互独立，这样不会影响到整个应用程序 2.进程可以将任务分成更多细小的任务，然后通过创建多个线程并行执行不同的任务，同一进程下的线程之间是可以直接通信、共享数据的

单进程浏览器 1.不安全 2.不稳定 3.不流畅
多进程浏览器

输入地址时：浏览器 ui 线程会捕捉你输入的内容
如果是 地址 启动 -> 网络线程进行网络请求
如果是 关键词 默认配置的搜索引擎来查询

当网络线程获取到数据会通过 safeBrowsing 来检查站点，是否是恶意站点(谷歌内部的一套站点安全系统)通过检测该站点的数据来判断是否安全，比如查看 ip 地址是否在谷歌的黑名单之内

网络线程 会通知 UI 线程 -> 会创建一个渲染进程来渲染页面，浏览器进程通过 IPC 管道将数据传递给渲染器进程。
渲染进程的主线程对 1.html 进行解析 2.构造 DOM(文档对象模型，是浏览器对页面在其内部的表示形式)数据结构

- html 解析
  html 首先经过 tokeniser 标记化，通过词法分析将输入的 html 内容解析成多个标记，根据识别后的标记进行 DOM 树构造
  在 DOM 树构造过程中会创建 document 对象，然后以 document 的为根结点的 dom 树不断进行修改，向其中添加各种元素

html 代码中往往会引入一些额外的资源，比如图片、css、js 脚本图片和 css 资源需要通过网络下载或从缓存中直接加载，这些资源不会阻塞 html 解析，因为它们不会影响 dom 的生成
但当 html 解析过程中遇到 script 标签，就会停止 html 解析流程，转而去加载解析并执行 js

为什么不跳过 js
这是因为浏览器并不知道 js 执行是否会改变当前页面的 html 结构，如果 js 代码里用了 document.write
方法来修改 html，那之前的 html 解析就没任何意义了，这也就是为什么把 script 标签要放在合适的位置 或者使用 async 和 defer 属性异步加载 js

- style
  html 解析完成后形成一个 domtree，主线程需要解析 css，并确定每个 dom 节点的计算样式，即使没有提供自定义的 css 样式
  浏览器会有自己默认的样式表 比如 h2 h3
- layout 布局 节点位置、坐标、占用多大区域
  主线程通过遍历 dom 和计算好的样式来生成 layout Tree，layout 上面的每个节点都记录了 x,y 坐标和边框尺寸，其中注意的是 dom tree 和 layout tree 并不是一一对应的
  如果设置 display 为 none 的节点不会出现在 layout Tree 上
  而在伪类 before 中添加了 content 值的元素，content 里的内容会出现在 layout tree 上，不会出现在 dom 树里

这是因为 dom 是通过 html 解析获得，并不关系样式，而 layout tree 是根据 dom tree 和计算样式来生成。layout tree 与页面展示节点是一一对应的

- paint
  z-index 属性会影响节点绘制层级关系，如果按照 dom 的层级结构来渲染页面则会导致错误的渲染
  文档的绘制顺序：为了保证在屏幕上展示正确的层级，主线程遍历 layout tree 创建一个绘制记录表(paint)，该表记录了绘制的顺序，这个阶段被称为绘制

栅格化：将这些信息转换为像素点

- layer
  chrome 很久前 只栅格用户可视化的内容，当用户滚动页面时，在栅格化更多的内容来填充缺失的部分，这种方式带来的问题显而易见，会导致展示延迟
  随着不断的优化升级，chrome 使用了更为复杂的栅格化流程，叫做合成，合成是一种将页面的各个部分分成多个图层，分别对其进行栅格化，并在合成器线程中单独合成页面的技术
  简单来说就是页面所有元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可

主线程遍历 layout tree 生成 layer(图层) tree 当 layer tree 生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程
合成器线程将每个图层栅格化，由于一层可能像页面的整个长度一样大，因此合成器线程将他们切分为许多图块
然后将每个图块发送给栅格线程，栅格线程栅格化每个图块，并将它们存储在 GPU 内存中，当图块栅格化完成后
合成器线程将收集称为 draw quads 的图块信息 ，这些信息里记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息，根据这些信息合成器线程生成一个合成器帧，然后合成器帧通过 IPC 传送给浏览器进程，接着浏览器进程将合成器帧传送给 GPU，然后 GPU 渲染展示到屏幕上

当滚动页面都会生成一个新的合成器帧 -> 新的帧再传给 GPU -> 再次渲染到屏幕上

主线程 dom style layout paint layer

合成器线程 tiles frame
栅格线程 draw quads

每秒以 60 帧才不会让用户感觉到页面卡顿，如果在运行动画时还有大量的 js 任务需要执行
因为布局、绘制和 js 执行都在主线程运行的，当在一帧的时间内布局和绘制结束后，还有剩余时间，js 就会拿到主线程的使用权，如果 js 执行时间过长，就会
导致下一帧开始时 js 没有及时归还主线程，导致下一帧的动画没有按时渲染，就会出现页面动画的卡顿

通过什么优化
1.requestAnimationFrame() 会在每一帧被调用，可以吧 js 运行任务分成一些更小的任务块(分到每一帧)
在每一帧时间用完前暂停 js 执行，归还主线程，这样的话在下一帧开始时，主线程就可以按时执行布局和绘制
2.css 通过有个属性 transform，通过该属性实现通过不会经过布局和绘制，而是直接运行在合成器线程和栅格线程中，所以不会受到主线程中 js 执行的影响，
更重要的是通过 transform 实现了通过由于不需要经过布局绘制、样式计算等操作所以节省了很多运算时间
