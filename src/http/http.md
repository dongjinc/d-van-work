https://feisky.gitbooks.io/sdn/content/basic/tcpip.html
https://www.cnblogs.com/imyalost/p/5629606.html
1.http、https
 2.强缓存与协商缓存
3.url

TCP/IP 1.链路层 封装、解封装 IP 报文，发送和接受 ARP/PARP 报文 2.网络层 路由以及分组报文发送给目标网络或主机 3.传输层 对报文进行分组和重组，并以 TCP 或 UDP 协议格式封装报文 4.应用层 向用户提供应用程序，比如 HTTP、FTP、Telnet、DNS

OSI 七层模型 7.应用层 6.表示层 5.会话层 4.传输层 3.网络层 2.数据链路层 1.物理层

无状态：http 协议是一种自身不对 请求和响应之间的通信状态进行保存的协议，即无状态协议
后来有 cookie

持久性：发送 http 请求，都需要建立 TCP 的连接，再发送报文
http 有一个 connection 属性，用于指定连接的方式
当设置成 keep-alive，http 就会建立一条持久化的连接，不需要每次都建立连接，再中断

管线化：使得 http 请求比持久性连接更要快；特点：请求数越多，时间差越明显

内容编码：为了减少传输时间，会采取一些压缩的措施
Accept-Encoding 定义内容编码的格式：gzip
gzip：Gun 压缩格式
compress：UNIX 系统的标准压缩格式
deflate：使用 LZ77 和哈弗曼的无损压缩格式
identity：不进行压缩

多部分对象集合：传输时不仅是一些字符串，还有可能是图片，字符串，二进制
例如在使用 java 编写 web 上传文件的代码时，需要在 form 中指定 form 的编码格式
multipart
设置 form 的 enctype 属性的值为 multipart/form-data
默认情况下 form 使用的编码格式是：application/x-www-form-urlencoded

范围请求：http 报文请求一些很大图片，加载过程很慢
有时候图片是一快一块加载的。因为设置了 http 请求的长度，这样可以分块加载资源文件
在请求报文中使用 Range 属性，响应体报文中使用 Content-Type 属性也可以指定一定字节范围

http 协议的数据传输方式
GET 和 POST
区别：
目标不同：get 方法只是用来查询，不会对浏览器上的信息产生影响
大小不同：get 放在 URL 首部，随浏览器而定，post 在报文中，只要没具体限制，文件的大小是没限制的
安全性：get 明文传输，post 放在报文中

关于三次握手，我是这样理解的，前面的随笔有说到通信过程，
三次握手基于 http 协议的四个层次，从应用层到网络层。层层打
上标签，然后到达服务端的过程中又层层解封，返回响应也是
这样，这是简单的一个通信过程，也是数据包封装发送的过程，
这篇随笔我没有详细解释，可能是因为之前觉得已经写过这些
内容了，


多路复用 代替原来的序列和阻塞机制，所有就是请求的都是通过一个TCP连接并发完成
同时也很好的解决了浏览器限制同一个域名下的请求数量的问题
http2 有了二进制分帧之后，http2不再依赖TCP链接去实现多流并行了：

1.同域名下所有通信都在单个连接上完成，同一域名只需要占一个TCP连接，使用一个连接并行发送多个请求和响应
2.单个连接可以承载任意数量的双向数据流，单个连接上可以并行交错的请求和响应

帧：数据传输的最小单位，每个帧都会标识出该帧属于哪个流，流也就是多个帧组成的数据流
流：存在与连接中的一个虚拟通道

http2采用二进制数据帧传输，取代了http1.x的文本格式，二进制格式解析更高效


多路复用是对同一域名下所有请求都是基于流，所以不存在同域并行的阻塞
代替了http1.x的序列和阻塞机制，所有相同域名请求都通过同一个tcp连接并发完成。同一个tcp中可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。


多个TCP连接
没有keep-alive值，智能创建多个TCP连接来做多次请求

Keep-Alive
解决的核心问题是：一定时间内，同一域名多次请求数据，只建立一次http请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。

存在如下问题：
串行的文件传输
同域并行请求限制带来的阻塞(6-8)个

管线化：http管线化可以克服同域并行请求限制带来的阻塞，它是建立在持久连接之上，把所有请求一并发给服务器，但是服务器需要按照顺序一个一个响应，而不是等到一个响应回来才能发下一个请求，节省了很多请求到服务器的时间

存在如下问题：
若上一响应迟迟不回，后面的响应都会被阻塞到

http超文本传输协议 用于传输html的超媒体文档的应用层协议
http是一个基于TCP/IP通信协议来传递数据，也通过三次握手，四次挥手

http/0.9 不涉及数据包传输，主要规定了客户端和服务器之间的通信格式

http/1.0 
1.任何格式的内容都可以发送。图片、视频、二进制文件
2.除了GET还引入POST和HEAD命令
3.http请求和回应格式，每次通信都必须包括头信息，用来描述一些元数据
4.状态码、多字符集支持、多部分发送、权限、缓存、内容编码
存在问题：
主要缺点，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭。如果还需请求其他资源，必须在新建一个连接
tcp连接的新建成本很高，需要客户端和服务器三次握手

http/1.1
长连接：http1.1支持长连接和请求的流水线处理，在一个tcp连接上可以传送多个http请求和响应。默认开启connection:keep-alive
缓存处理：
http1.0中主要使用header里的if-Modified-Since Expires
http1.1中Entity tag、if-none-match 
带宽优化以及网络连接的使用：
http1.0 浪费带宽现象、不支持断点续传功能。
http1.1 请求头引入range头域，允许只请求资源的某个部分
host头处理：
http1.0中认为每台服务器都绑定一个唯一的ip地址，请求消息中没有传递主机名。
虚拟主机的发展，一台物理服务器可存在多个虚拟主机，共享一个ip地址。
http1.1请求消息和响应消息都支持host头域
存在问题：
允许复用tcp连接，同一个tcp连接里面，所有的数据通信是按次序进行的。
服务器只有处理完一个回应，才能进行下一个回应。如果前面回应很慢，后面请求排队等着。队头阻塞
http1.x在传输数据时，所有传输的内容都是明文。客户端和服务端无法验证
http1.x在使用时，header携带内容过大，在一定程度上增加传输的成本。
http1.x支持keep-alive，使用多了同样会给服务器端带来大量的性能压力。当文件被请求之后还保持不必要的连接很长时间

SPDY协议 谷歌自行研发 主要解决http1.1效率不高问题
降低延迟，针对http高延迟问题，SPDY优雅采取了多路复用。通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高带宽的利用率
请求优先级：多路复用新问题，连接共享的基础之上有可能会导致关键请求被阻塞。
SPDY允许给每个request设置优先级，这样重要请求会优先得到响应
header压缩
基于https的加密协议传输，提高传输数据的可靠性
服务器推送

HTTP => SPDY => SSL => TCP

http2 SPDY升级版
1.支持明文http传输，而SPDY强制使用https
2.消息头的压缩算法采用HPACK，SPDY采用deflate

帧 客户端与服务器通过交换帧来通信
消息 http消息，比如请求、响应，由一或多个帧组成
流 连接中的一个虚拟信道，承载双向的消息

数据流 => 消息的形式发送 => 消息由一或多个帧组成。帧是流中的数据单位

多路复用 允许同时通过单一的http/2连接发起多重的请求-响应消息。即连接共享
请求优先级
header压缩
http2使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表
